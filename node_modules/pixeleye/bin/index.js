#! /usr/bin/env node


// src/commands.ts
import chalk2 from "chalk";
import { Command as Command2 } from "commander";

// src/config-loader.ts
import { program } from "commander";
import { loadConfig, defaultConfig } from "@pixeleye/cli-config";
import { setEnv } from "@pixeleye/cli-env";
async function loadAndMergeConfig(hookedCommand, subCommand) {
  const commands = hookedCommand.opts();
  const configPath = commands.config || commands.c;
  const config = await loadConfig(configPath);
  for (const [key, value] of Object.entries(config)) {
    let mappedKey = optionMap[key] || key;
    if (mappedKey === "wait") {
      mappedKey = "waitForStatus";
    }
    const defaultValue = defaultConfig[mappedKey];
    const newValue = commands[mappedKey] ?? value ?? defaultValue;
    subCommand.setOptionValue(mappedKey, newValue);
    commands[mappedKey] = newValue;
  }
  if (!commands.token)
    program.error(
      "Pixeleye project token required. Please provide it via the command line or a config file.",
      {
        exitCode: 9,
        code: "PIXELEYE_TOKEN_REQUIRED"
      }
    );
  const envBoothPort = process.env.PIXELEYE_BOOTH_PORT;
  if (!commands.boothPort && envBoothPort) {
    subCommand.setOptionValue("boothPort", envBoothPort);
    commands.boothPort = envBoothPort;
  }
  setEnv("PIXELEYE_BOOTH_PORT", commands.boothPort);
}

// src/handlers/ping.ts
import { API } from "@pixeleye/cli-api";
import ora from "ora";
async function ping(options) {
  const api = API({
    endpoint: options.endpoint,
    token: options.token
  });
  const pingSpinner = ora("Pinging Pixeleye API").start();
  await api.get("/v1/ping", {}).catch((err) => {
    pingSpinner.fail("Pixeleye API is not reachable");
    console.log(err);
    throw err;
  });
  pingSpinner.succeed("Pixeleye API is up and running");
}

// src/handlers/storybook.ts
import ora3 from "ora";
import { ping as ping3 } from "@pixeleye/cli-booth";
import { program as program3 } from "commander";
import { captureStories } from "@pixeleye/storybook";

// src/messages/ui/theme.ts
import chalk from "chalk";
import dedent from "dedent";
function errMsg(strings, ...args) {
  const str = strings.reduce(
    (acc, curr, i) => acc + curr + (args[i] || ""),
    ""
  );
  return dedent(chalk.bold.red(str));
}
function errStr(str) {
  if (typeof str === "object") {
    return chalk.bold.red(JSON.stringify(str, null, 2));
  }
  return chalk.bold.red(str);
}
function infoPrefix(prefix, content) {
  return chalk.hex("00BFFF")(prefix) + chalk.white(content);
}

// src/handlers/storybook.ts
import { API as API2, createBuild } from "@pixeleye/cli-api";

// src/handlers/utils.ts
import { program as program2 } from "commander";
import ora2 from "ora";
import { execFile } from "node:child_process";
import { logger } from "@pixeleye/cli-logger";
import { finished, ping as ping2 } from "@pixeleye/cli-booth";
import EventSource from "eventsource";
import { installBrowsers } from "@pixeleye/cli-install";
import { fileURLToPath } from "node:url";
import { dirname } from "node:path";
var _dirname = typeof __dirname !== "undefined" ? __dirname : dirname(fileURLToPath(import.meta.url));
var getExitBuild = (api, buildID) => async (err) => {
  console.log(errStr(err));
  const abortingSpinner = ora2({
    text: "Aborting build...",
    color: "yellow"
  }).start();
  await api.post("/v1/client/builds/{id}/abort", {
    params: {
      id: buildID
    }
  }).catch((err2) => {
    abortingSpinner.fail("Failed to abort build.");
    console.log(errStr(err2));
    program2.error(err2);
  }).then(() => {
    abortingSpinner.succeed("Successfully aborted build.");
  });
  program2.error(err);
};
function watchExit(callback) {
  [
    "SIGINT",
    "SIGHUP",
    "SIGQUIT",
    "SIGTERM",
    "uncaughtException",
    "exit"
  ].forEach((signal) => {
    process.on(signal, async () => {
      await callback();
    });
  });
}
var startBooth = async ({
  buildID,
  token,
  endpoint,
  boothPort
}) => {
  await installBrowsers();
  return execFile(
    "node",
    [
      "booth.js",
      "start",
      `"${buildID}"`,
      `"${token}"`,
      endpoint ? `-e ${endpoint}` : "",
      boothPort ? `-p ${boothPort}` : ""
    ],
    {
      cwd: _dirname,
      env: process.env
    },
    (error, stdout, stderr) => {
      if (error) console.error(error);
      if (stdout) logger.verbose(stdout);
      if (stderr) console.error(stderr);
    }
  );
};
var waitForProcessing = async ({
  boothPort
}) => {
  const maxRetries = 3;
  for (let i = 0; i < maxRetries; i++) {
    await new Promise((r) => setTimeout(r, 1e3));
    const res = await finished({
      endpoint: `http://localhost:${boothPort}`
    }).catch(async (err) => {
      await ping2({
        endpoint: `http://localhost:${boothPort}`
      }).catch(async () => {
        throw err;
      });
      return { status: 500 };
    });
    if (res.status === 200) return;
  }
  throw new Error("Failed to upload snapshots.");
};
function splitIntoChunks(array, chunkSize) {
  return array.flatMap(
    (_, i) => i % chunkSize === 0 ? [array.slice(i, i + chunkSize)] : []
  );
}
async function waitForBuildResult(token, build, endpoint) {
  return new Promise((resolve, reject) => {
    const es = new EventSource(
      `${endpoint || "https://api.pixeleye.io"}/v1/client/builds/${build.id}/events?initial=true`,
      {
        headers: { Authorization: `Bearer ${token}` },
        withCredentials: true
      }
    );
    es.addEventListener("message", (event) => {
      const data = JSON.parse(event.data);
      if (data.type === "build_status") {
        const newStatus = data.data.status;
        if ([
          "processing",
          "queued-processing",
          "uploading",
          "queued-uploading"
        ].includes(newStatus)) {
          return;
        }
        resolve(newStatus);
      }
    });
    es.onerror = (err) => {
      reject(err);
    };
  });
}

// src/handlers/storybook.ts
import { setEnv as setEnv2 } from "@pixeleye/cli-env";
async function storybook(url, options) {
  let buildFinished = false;
  setEnv2("PIXELEYE_RUNNING", "true");
  const api = API2({
    endpoint: options.endpoint,
    token: options.token
  });
  const buildSpinner = ora3("Creating build").start();
  const build = await createBuild(api).catch(async (err) => {
    buildSpinner.fail("Failed to create build.");
    console.log(errStr(err));
    program3.error(err);
  });
  buildSpinner.succeed("Successfully created build.");
  const exitBuild = getExitBuild(api, build.id);
  const onExitFns = [
    async () => {
      if (buildFinished) return;
      console.log(errStr("\nAborting build..."));
      await exitBuild("Interrupted");
    }
  ];
  watchExit(async () => {
    await Promise.all(onExitFns.map((fn) => fn()));
  });
  const fileSpinner = ora3("Starting local snapshot server").start();
  const child = await startBooth({
    buildID: build.id,
    token: options.token,
    endpoint: options.endpoint,
    boothPort: options.boothPort
  });
  onExitFns.push(async () => {
    child.kill();
  });
  fileSpinner.succeed("Successfully started local snapshot server.");
  const pingSpinner = ora3("Pinging booth server").start();
  await ping3({
    endpoint: `http://localhost:${options.boothPort}`
  }).catch(async (err) => {
    pingSpinner.fail("Failed to ping booth server.");
    await exitBuild(err);
  });
  pingSpinner.succeed("Successfully pinged booth server.");
  const storybookSpinner = ora3(
    `Capturing stories at ${url}, Snapshots captured: 0`
  ).start();
  let totalSnaps = 0;
  await captureStories({
    storybookURL: url,
    devices: options.devices,
    variants: options.storybookOptions?.variants,
    callback({ current }) {
      totalSnaps = current;
      storybookSpinner.text = `Capturing stories at ${url}, Snapshots captured: ${current}`;
      return Promise.resolve();
    }
  }).catch(async (err) => {
    storybookSpinner.fail("Failed to capture stories.");
    await exitBuild(err);
  });
  storybookSpinner.succeed(
    `Successfully captured stories (${totalSnaps} snaps in total)`
  );
  const processingSpinner = ora3(
    "Waiting for device capturing and uploads to finish"
  ).start();
  await waitForProcessing({
    boothPort: options.boothPort
  }).catch(async (err) => {
    processingSpinner.fail("Device capturing and uploads failed.");
    await exitBuild(err);
  });
  processingSpinner.succeed(
    "Successfully processed device capturing and uploads."
  );
  const completeSpinner = ora3("Completing build...").start();
  await api.post("/v1/client/builds/{id}/complete", {
    params: {
      id: build.id
    }
  }).catch(async (err) => {
    completeSpinner.fail("Failed to complete build.");
    await exitBuild(err);
  });
  completeSpinner.succeed("Successfully completed build.");
  buildFinished = true;
  if (options.waitForStatus) {
    const waitForStatus = ora3("Waiting for build to finish processing").start();
    const finalStatus = await waitForBuildResult(
      options.token,
      build,
      options.endpoint
    ).catch(async () => {
      waitForStatus.fail("Failed to wait for build to finish processing.");
      await process.exit(1);
    });
    waitForStatus.succeed("Successfully finished processing build.");
    console.log(`
Build status: ${finalStatus}`);
  }
  child.kill();
  process.exit(0);
}

// src/handlers/exec.ts
import ora4 from "ora";
import { ping as ping4 } from "@pixeleye/cli-booth";
import { program as program4 } from "commander";
import { exec } from "child_process";
import { API as API3, createBuild as createBuild2 } from "@pixeleye/cli-api";

// src/messages/exec.ts
var execOutput = (msg) => infoPrefix("e2e output: ", msg);

// src/handlers/exec.ts
import { setEnv as setEnv3 } from "@pixeleye/cli-env";
async function execHandler(command, options) {
  let buildFinished = false;
  setEnv3("PIXELEYE_RUNNING", "true");
  const api = API3({
    endpoint: options.endpoint,
    token: options.token
  });
  const buildSpinner = ora4("Creating build").start();
  const build = await createBuild2(api, {
    shardingCount: options.count,
    shardID: options.shard
  }).catch(async (err) => {
    buildSpinner.fail("Failed to create build.");
    console.log(errStr(err));
    program4.error(err);
  });
  buildSpinner.succeed("Successfully created build.");
  const exitBuild = getExitBuild(api, build.id);
  const onExitFns = [
    async () => {
      if (buildFinished) return;
      console.log(errStr("\nAborting build..."));
      await exitBuild("Interrupted");
    }
  ];
  watchExit(async () => {
    await Promise.all(onExitFns.map((fn) => fn()));
  });
  const fileSpinner = ora4("Starting local snapshot server").start();
  const child = await startBooth({
    buildID: build.id,
    token: options.token,
    endpoint: options.endpoint,
    boothPort: options.boothPort
  });
  onExitFns.push(async () => {
    child.kill();
  });
  fileSpinner.succeed("Successfully started local snapshot server.");
  const pingSpinner = ora4("Pinging booth server").start();
  await ping4({
    endpoint: `http://localhost:${options.boothPort}`
  }).catch(async (err) => {
    pingSpinner.fail("Failed to ping booth server.");
    await exitBuild(err);
  });
  pingSpinner.succeed("Successfully pinged booth server.");
  ora4(`Running command (${command.join(" ")}) ...`).info();
  const promise = () => new Promise((resolve, reject) => {
    const child2 = exec(command.join(" "), {
      cwd: process.cwd()
    });
    child2.on("error", (err) => {
      console.log(err);
      reject(err);
    });
    child2.on("exit", (code) => {
      if (code === 0) {
        resolve(void 0);
      } else {
        reject();
      }
    });
    child2.stdout?.on("data", (data) => {
      console.log(execOutput(data.toString()));
    });
  });
  await promise().catch(async (err) => {
    ora4().fail("Failed to run command.");
    await exitBuild(err);
  });
  ora4().succeed("Successfully ran command.");
  const processingSpinner = ora4(
    "Waiting for device capturing and uploads to finish"
  ).start();
  await waitForProcessing({
    boothPort: options.boothPort
  }).catch(async (err) => {
    processingSpinner.fail("Device capturing and uploads failed.");
    await exitBuild(err);
  });
  processingSpinner.succeed(
    "Successfully processed device capturing and uploads."
  );
  const completeSpinner = ora4("Completing build...").start();
  await api.post("/v1/client/builds/{id}/complete", {
    params: {
      id: build.id
    }
  }).catch(async (err) => {
    completeSpinner.fail("Failed to complete build.");
    await exitBuild(err);
  }).then(() => {
    completeSpinner.succeed("Successfully completed build.");
    buildFinished = true;
  });
  if (options.waitForStatus) {
    const waitForStatus = ora4("Waiting for build to finish processing").start();
    const finalStatus = await waitForBuildResult(
      options.token,
      build,
      options.endpoint
    ).catch(async () => {
      waitForStatus.fail("Failed to wait for build to finish processing.");
      await process.exit(1);
    });
    waitForStatus.succeed("Successfully finished processing build.");
    console.log(`
Build status: ${finalStatus}`);
  }
  child.kill();
  process.exit(0);
}

// src/handlers/upload.ts
import ora5 from "ora";
import { program as program5 } from "commander";
import { API as API4, createBuild as createBuild3, uploadSnapshots } from "@pixeleye/cli-api";
import fsCallback from "graceful-fs";
import { promisify } from "util";
import { join } from "path";

// src/messages/files.ts
var dirNotFound = (path) => errMsg`No such directory: ${path}
        Please make sure you are in the right directory and the path is correct.`;
var noImagesFound = (path) => errMsg`No images found in ${path}
            Please make sure you are in the right directory and the path is correct.`;

// src/handlers/upload.ts
var fs = {
  readdir: promisify(fsCallback.readdir),
  readFile: promisify(fsCallback.readFile)
};
async function readAllFiles(path) {
  const dir = join(process.cwd(), path);
  return fs.readdir(dir, {
    withFileTypes: true
  }).then(
    (files) => files.filter((file) => file.isFile() && file.name.endsWith(".png"))
  );
}
function decode(fileName) {
  const decoded = decodeURIComponent(fileName);
  const [name, variant] = decoded.split("--").map((str) => str.trim()).map((str) => str.replaceAll("\\-", "-"));
  return {
    name,
    variant: variant?.replace(/\.png$/, "")
  };
}
async function uploadHandler(dir, options) {
  const api = API4({
    endpoint: options.endpoint,
    token: options.token
  });
  const fileSpinner = ora5("Reading files").start();
  const files = await readAllFiles(dir).catch((err) => {
    fileSpinner.fail("Failed to read files.");
    console.log(errStr(err.toString()));
    if (err?.code === "ENOENT") {
      dirNotFound(dir);
      process.exit(9);
    }
    program5.error(err);
  });
  if (!files || files.length === 0) {
    fileSpinner.fail("Failed to read files.");
    noImagesFound(dir);
    process.exit(9);
  }
  fileSpinner.succeed("Successfully read files.");
  const buildSpinner = ora5("Creating build").start();
  const build = await createBuild3(api).catch(async (err) => {
    buildSpinner.fail("Failed to create build.");
    console.log(errStr(err));
    program5.error(err);
  });
  buildSpinner.succeed("Successfully created build.");
  const exitBuild = getExitBuild(api, build.id);
  watchExit(async () => {
    console.log(errStr("\nAborting build..."));
    await exitBuild("Interrupted");
  });
  const uploadingSpinner = ora5("Uploading files").start();
  const groups = splitIntoChunks(files, 20);
  try {
    for (const files2 of groups) {
      const readFiles = await Promise.all(
        files2.map(async (f) => ({
          file: await fs.readFile(join(process.cwd(), dir, f.name)),
          format: "image/png",
          name: f.name
        }))
      );
      const uploaded = await uploadSnapshots(
        options.endpoint,
        options.token,
        readFiles
      );
      if (uploaded.length > 0)
        await api.post("/v1/client/builds/{id}/upload", {
          params: {
            id: build.id
          },
          body: {
            snapshots: readFiles.map(
              ({ name, format }, i) => ({
                name: decode(name).name,
                variant: decode(name).variant,
                format,
                snapID: uploaded[i].id,
                target: "unknown device"
              })
            )
          }
        });
    }
  } catch (err) {
    uploadingSpinner.fail("Failed to upload snapshots to Pixeleye.");
    await exitBuild(err);
  }
  uploadingSpinner.succeed("Successfully uploaded snapshots to Pixeleye.");
  const completeSpinner = ora5("Completing build...").start();
  await api.post("/v1/client/builds/{id}/complete", {
    params: {
      id: build.id
    }
  }).catch(async (err) => {
    completeSpinner.fail("Failed to complete build.");
    await exitBuild(err);
  });
  completeSpinner.succeed("Successfully completed build.");
  if (options.waitForStatus) {
    const waitForStatus = ora5("Waiting for build to finish processing").start();
    const finalStatus = await waitForBuildResult(
      options.token,
      build,
      options.endpoint
    ).catch(async () => {
      waitForStatus.fail("Failed to wait for build to finish processing.");
      await process.exit(1);
    });
    waitForStatus.succeed("Successfully finished processing build.");
    console.log(`
Build status: ${finalStatus}`);
  }
  process.exit(0);
}

// src/handlers/snapFile.ts
import ora6 from "ora";
import { ping as ping5, snapshot } from "@pixeleye/cli-booth";
import { program as program6 } from "commander";
import { API as API5, createBuild as createBuild4 } from "@pixeleye/cli-api";
import { readSnapshotFiles } from "@pixeleye/cli-config";
import Sitemapper from "sitemapper";
async function snapFileHandler(files, options) {
  let buildFinished = false;
  const api = API5({
    endpoint: options.endpoint,
    token: options.token
  });
  const readFilesSpinner = ora6("Reading url files").start();
  const snapshotURLs = await readSnapshotFiles([
    ...files,
    ...options.snapshotFiles || []
  ]).catch((err) => {
    readFilesSpinner.fail("Failed to read url files.");
    program6.error(err);
  });
  readFilesSpinner.succeed("Successfully read url files.");
  if (options.urls && options.urls.length > 0) {
    const cmdURLs = ora6("Parsing urls from command line").start();
    snapshotURLs.push(
      ...options.urls.map((url) => ({ url })).filter(
        ({ url }) => !snapshotURLs.some((existing) => existing.url === url)
      )
    );
    cmdURLs.succeed("Successfully parsed urls from command line");
  }
  if (options.sitemaps && options.sitemaps.length > 0) {
    const sitemapURLs = ora6("Parsing urls from sitemaps").start();
    const sitemap = new Sitemapper({});
    const urls = await Promise.all(
      options.sitemaps.map(async (sitemapURL) => sitemap.fetch(sitemapURL))
    ).catch((err) => {
      sitemapURLs.fail("Failed to parse urls from sitemaps.");
      program6.error(err);
    });
    snapshotURLs.push(
      ...urls.flatMap(
        ({ sites }) => sites.map((url) => ({ url })).filter(
          ({ url }) => !snapshotURLs.some((existing) => existing.url === url)
        )
      )
    );
    sitemapURLs.succeed("Successfully parsed urls from sitemaps");
  }
  if (snapshotURLs.length === 0) {
    console.log(errStr("No URLs to snapshot."));
    process.exit(1);
  }
  ora6(`Found ${snapshotURLs.length} URLs to snapshot.`).info();
  const buildSpinner = ora6("Creating build").start();
  const build = await createBuild4(api).catch(async (err) => {
    buildSpinner.fail("Failed to create build.");
    console.log(errStr(err));
    program6.error(err);
  });
  buildSpinner.succeed("Successfully created build.");
  const exitBuild = getExitBuild(api, build.id);
  const onExitFns = [
    async () => {
      if (buildFinished) return;
      console.log(errStr("\nAborting build..."));
      await exitBuild("Interrupted");
    }
  ];
  watchExit(async () => {
    await Promise.all(onExitFns.map((fn) => fn()));
  });
  const fileSpinner = ora6("Starting local snapshot server").start();
  const child = await startBooth({
    buildID: build.id,
    token: options.token,
    endpoint: options.endpoint,
    boothPort: options.boothPort
  });
  onExitFns.push(async () => {
    child.kill();
  });
  fileSpinner.succeed("Successfully started local snapshot server.");
  const pingSpinner = ora6("Pinging booth server").start();
  await ping5({
    endpoint: `http://localhost:${options.boothPort}`
  }).catch(async (err) => {
    pingSpinner.fail("Failed to ping booth server.");
    await exitBuild(err);
  });
  pingSpinner.succeed("Successfully pinged booth server.");
  const captureURlSpinner = ora6("Capturing URLs").start();
  await Promise.all(
    snapshotURLs.map(
      async (url) => snapshot(
        {
          endpoint: `http://localhost:${options.boothPort}`
        },
        {
          ...url,
          devices: options.devices,
          name: url.name || url.url,
          css: `${options.css || ""}
${url.css || ""}`
        }
      )
    )
  ).catch(async (err) => {
    captureURlSpinner.fail("Failed to capture URLs.");
    await exitBuild(err);
  });
  captureURlSpinner.succeed("Successfully captured URLs.");
  const processingSpinner = ora6(
    "Waiting for device capturing and uploads to finish"
  ).start();
  await waitForProcessing({
    boothPort: options.boothPort
  }).catch(async (err) => {
    processingSpinner.fail("Device capturing and uploads failed.");
    await exitBuild(err);
  });
  processingSpinner.succeed(
    "Successfully processed device capturing and uploads."
  );
  const completeSpinner = ora6("Completing build...").start();
  await api.post("/v1/client/builds/{id}/complete", {
    params: {
      id: build.id
    }
  }).catch(async (err) => {
    completeSpinner.fail("Failed to complete build.");
    await exitBuild(err);
  }).then(() => {
    completeSpinner.succeed("Successfully completed build.");
    buildFinished = true;
  });
  if (options.waitForStatus) {
    const waitForStatus = ora6("Waiting for build to finish processing").start();
    const finalStatus = await waitForBuildResult(
      options.token,
      build,
      options.endpoint
    ).catch(async () => {
      waitForStatus.fail("Failed to wait for build to finish processing.");
      await process.exit(1);
    });
    waitForStatus.succeed("Successfully finished processing build.");
    console.log(`
Build status: ${finalStatus}`);
  }
  child.kill();
  process.exit(0);
}

// src/commands.ts
import { setLogLevel } from "@pixeleye/cli-logger";
var program7 = new Command2();
program7.configureOutput({
  writeErr: (str) => process.stderr.write(chalk2.red(str)),
  writeOut: (str) => process.stdout.write(chalk2.green(str))
});
var optionMap = {
  t: "token",
  e: "endpoint",
  p: "boothPort",
  w: "wait",
  v: "verbose",
  c: "config",
  sm: "sitemaps",
  u: "urls"
};
var configOption = (name) => program7.command(name).option(
  "-c, --config [path]",
  "Path to config file, e.g. ./config/pixeleye.config.js"
);
var verboseOption = (name) => configOption(name).option("-v, --verbose", "Verbose output").hook("preAction", (hookedCommand) => {
  const commands = hookedCommand.opts();
  if (commands.verbose || commands.v) setLogLevel("verbose");
});
var apiOptions = (name) => verboseOption(name).option("-t, --token <token>", "Pixeleye project token").option(
  "-e, --endpoint [endpoint]",
  "Pixeleye API endpoint (only use if self-hosting)"
);
apiOptions("ping").description("Test your connection to pixeleye").hook("preAction", loadAndMergeConfig).action(ping);
apiOptions("storybook").argument(
  "[url]",
  "URL to storybook, can be local or remote",
  "http://localhost:6006"
).option(
  "-w, --wait [wait]",
  "Wait for build results, outputting them once finished processing",
  "false"
).description("Run storybook and upload screenshots to pixeleye").hook("preAction", loadAndMergeConfig).action(storybook);
apiOptions("exec").argument("[command...]", "Command to execute").option(
  "-w, --wait [wait]",
  "Wait for build results, outputting them once finished processing",
  "false"
).option("--count [count]", "Number of shards to split the build into").option(
  "--shard [shard]",
  "An identifier for the shard, use something unique like the CI job id. We'll attempt to set this automatically"
).description("Start your e2e tests with pixeleye running in the background").hook("preAction", loadAndMergeConfig).action(execHandler);
apiOptions("upload").argument("<dir?", "Directory to upload").option(
  "-w, --wait [wait]",
  "Wait for build results, outputting them once finished processing",
  "false"
).description("Upload screenshots to pixeleye").hook("preAction", loadAndMergeConfig).action(uploadHandler);
apiOptions("snapshot").argument(
  "[files...]",
  "File globs for pixeleye snapshot definitions. You can also declare these in your config file"
).option(
  "-sm, --sitemaps <sitemaps...>",
  "Sitemap URLs to snapshot, e.g. https://example.com/sitemap.xml. If a url has already been listed in a file], the file definition will take precedence."
).option(
  "-u, --urls <urls...>",
  "URLs to snapshot, e.g. https://example.com. If a url has already been listed in a file, the file definition will take precedence."
).option(
  "-w, --wait [wait]",
  "Wait for build results, outputting them once finished processing",
  "false"
).description(
  "Upload screenshots to pixeleye from a list of URL files passed in or defined in your config file"
).hook("preAction", loadAndMergeConfig).action(snapFileHandler);
var commands_default = program7.parse(process.argv);
export {
  optionMap,
  program7 as program
};
