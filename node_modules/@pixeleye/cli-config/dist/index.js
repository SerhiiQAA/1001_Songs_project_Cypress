var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/defaults.ts
import { devices } from "@pixeleye/cli-devices";
var defaultConfig = {
  boothPort: "3003",
  devices: [
    devices["Desktop Chrome"],
    devices["Desktop Firefox"],
    devices["Desktop Safari"],
    devices["Desktop Edge"]
  ],
  endpoint: "https://api.pixeleye.io",
  storybookOptions: {
    variants: []
  },
  boothConcurrency: 4,
  maskColor: "#FF00FF",
  css: void 0,
  waitForStatus: false
};

// src/loadConfig.ts
import { setEnv } from "@pixeleye/cli-env";
import jitiFactory from "jiti";
import { transform } from "sucrase";
import { join } from "node:path";
import { existsSync } from "node:fs";
import { fileURLToPath } from "node:url";
import fb from "fast-glob";
var _filename = typeof __filename !== "undefined" ? __filename : fileURLToPath(import.meta.url);
var jiti = null;
function isObject(item) {
  return Boolean(item) && typeof item === "object" && !Array.isArray(item);
}
function mergeObjects(defaultConfig2, userConfig) {
  const mergedConfig = {
    ...defaultConfig2,
    ...userConfig
  };
  for (const key of Object.keys(mergedConfig)) {
    if (isObject(defaultConfig2[key]) && isObject(userConfig[key])) {
      mergedConfig[key] = mergeObjects(
        defaultConfig2[key],
        userConfig[key]
      );
    }
  }
  return mergedConfig;
}
function lazyJiti() {
  return jiti ?? (jiti = jitiFactory(_filename, {
    interopDefault: true,
    transform: (opts) => {
      return transform(opts.source, {
        transforms: ["typescript", "imports"]
      });
    }
  }));
}
function readFile(path) {
  let config = function() {
    try {
      return path ? __require(path) : {};
    } catch {
      return lazyJiti()(path);
    }
  }();
  return config.default ?? config;
}
var toUpperCamelCase = (str) => str.replace(/[A-Z]/g, (letter) => `_${letter}`).toUpperCase();
async function loadConfig(path) {
  if (!path) {
    const endings = ["ts", "js", "cjs", "mjs"];
    const fileName = "pixeleye.config";
    for (const ending of endings) {
      if (existsSync(join(process.cwd(), `${fileName}.${ending}`))) {
        path = `${fileName}.${ending}`;
        break;
      }
    }
  }
  if (!path) {
    console.warn("No config file found.");
    return defaultConfig;
  }
  const relativePath = join(process.cwd(), path ?? "");
  let userConfig = readFile(relativePath);
  if (typeof userConfig === "function") {
    userConfig = await userConfig().catch((err) => {
      throw new Error(`Failed to load config file: ${err.message}`);
    });
  }
  if (typeof userConfig !== "object") {
    throw new Error(
      `Config file must export an object or a function that returns an object.`
    );
  }
  if (Object.keys(userConfig).length === 0) {
    console.log("Config is empty.");
  }
  const merged = mergeObjects(defaultConfig, userConfig);
  if (typeof merged.snapshotFiles === "function") {
    const { snapshotFiles: _, ...rest } = merged;
    merged.snapshotFiles = await merged.snapshotFiles(rest);
  }
  for (const key of Object.keys(merged)) {
    if (typeof merged[key] === "string") {
      setEnv(`PIXELEYE_${toUpperCamelCase(key)}`, merged[key]);
    } else {
      setEnv(`PIXELEYE_${toUpperCamelCase(key)}`, JSON.stringify(merged[key]));
    }
  }
  return merged;
}
async function readSnapshotFiles(files) {
  const fileNames = await fb(files, {
    absolute: true
  });
  return Promise.all(
    fileNames.map(async (fileName) => {
      const content = readFile(fileName);
      return typeof content === "function" ? content() : content;
    })
  ).then((results) => results.flat());
}

// src/getConfig.ts
function getEnvConfig(envFn) {
  if (!envFn) {
    envFn = (name) => process.env[name];
  }
  return {
    token: envFn("PIXELEYE_TOKEN") || "",
    boothPort: envFn("PIXELEYE_BOOTH_PORT"),
    endpoint: envFn("PIXELEYE_ENDPOINT"),
    css: envFn("PIXELEYE_CSS"),
    devices: JSON.parse(envFn("PIXELEYE_DEVICES") || "{}"),
    maskColor: envFn("PIXELEYE_MASK_COLOR"),
    boothConcurrency: Number(envFn("PIXELEYE_BOOTH_CONCURRENCY") || "4") || 4,
    storybookOptions: JSON.parse(
      envFn("PIXELEYE_STORYBOOK_OPTIONS") || "{}"
    )
  };
}
export {
  defaultConfig,
  getEnvConfig,
  loadConfig,
  readFile,
  readSnapshotFiles
};
