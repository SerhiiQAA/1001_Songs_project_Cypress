// src/capture.ts
import { pixeleyeSnapshot } from "@pixeleye/playwright";
import { chromium } from "playwright-core";
import { logger } from "@pixeleye/cli-logger";
async function openBrowser() {
  const browser = await chromium.launch({
    headless: true
  });
  const page = await browser.newPage();
  return { browser, page };
}
var timeout = (prom, time) => {
  let timer;
  return Promise.race([
    prom,
    new Promise((_r, rej) => timer = setTimeout(rej, time))
  ]).finally(() => clearTimeout(timer));
};
async function captureStories({
  storybookURL,
  variants,
  callback,
  devices
}) {
  const { browser, page } = await openBrowser();
  await page.goto(storybookURL);
  await page.goto(
    storybookURL + "/iframe.html?selectedKind=story-crawler-kind&selectedStory=story-crawler-story",
    {
      timeout: 12e4,
      waitUntil: "domcontentloaded"
    }
  );
  await page.waitForFunction(
    () => window.__STORYBOOK_PREVIEW__?.ready?.(),
    {
      timeout: 6e4
    }
  );
  await Promise.race([
    page.waitForFunction(
      () => window.__STORYBOOK_CLIENT_API__._storyStore.cacheAllCSFFiles,
      {
        timeout: 3e4
      }
    ).catch(() => {
    }),
    page.waitForFunction(
      () => window.__STORYBOOK_PREVIEW__.storyStoreValue.cacheAllCSFFiles,
      {
        timeout: 3e4
      }
    ).catch(() => {
    })
  ]);
  const result = await page.evaluate(async () => {
    const { __STORYBOOK_CLIENT_API__, __STORYBOOK_PREVIEW__ } = window;
    const store = __STORYBOOK_CLIENT_API__?._storyStore || __STORYBOOK_PREVIEW__?.storyStoreValue;
    await store.cacheAllCSFFiles();
    return {
      stories: Object.values(store.extract() || {}).map(
        ({ id, story, kind, parameters: { pixeleye } }) => ({
          id,
          story,
          kind,
          config: pixeleye
        })
      )
    };
  });
  if (variants === void 0 || variants.length === 0) {
    variants = [
      {
        name: "",
        params: ""
      }
    ];
  }
  let current = 0;
  for (const story of result.stories) {
    for (let variant of variants) {
      const storyConfig = story.config?.parameters?.pixeleye;
      if (storyConfig?.skip) continue;
      if (variant.params?.startsWith("?")) {
        variant.params = variant.params.substring(1);
      }
      if (!variant.params?.startsWith("&") && variant.params !== "") {
        variant.params = "&" + variant.params;
      }
      await page.goto(
        `${storybookURL}/iframe.html?id=${story.id}&viewMode=story${variant.params ? variant.params : ""}`,
        {
          waitUntil: "domcontentloaded"
        }
      );
      await page.waitForFunction(
        () => window.__STORYBOOK_PREVIEW__.channel,
        {
          timeout: 6e4
        }
      );
      await timeout(
        page.evaluate(() => {
          const { channel } = window.__STORYBOOK_PREVIEW__;
          return new Promise((resolve) => {
            channel.on("storyRendered", () => {
              resolve();
            });
          });
        }),
        6e4
      ).catch(() => {
        logger.info(
          `Didn't receive storyRendered event for ${story.id} in 60s, attempting to capture anyway`
        );
      });
      await page.waitForLoadState("load", {
        timeout: 6e4
      });
      await page.waitForFunction(() => document.fonts.ready).catch(() => {
        logger.info(
          `Time out waiting for document fonts to be ready for ${story.id}`
        );
      });
      if (storyConfig?.selector)
        await page.waitForSelector(storyConfig.selector);
      await pixeleyeSnapshot(page, {
        name: story.id,
        variant: variant.name,
        selector: storyConfig?.selector,
        devices
      });
      current += devices.length;
      callback?.({ current });
    }
  }
  await browser.close();
}
export {
  captureStories
};
