var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/browsers.ts
import { chromium, firefox, webkit } from "playwright-core";
import hash from "object-hash";
var browserCache = {};
var renderEngines = {
  chromium,
  firefox,
  webkit
};
async function getBrowser(deviceDescriptor) {
  const key = hash(deviceDescriptor.defaultBrowserType);
  if (browserCache[key]) {
    return browserCache[key];
  }
  const renderer = renderEngines[deviceDescriptor.defaultBrowserType];
  if (!renderer) {
    throw new Error(`Unknown renderer ${deviceDescriptor.defaultBrowserType}`);
  }
  const browser = await renderer.launch({
    headless: true
  });
  browserCache[key] = browser;
  return browser;
}
async function getPage(deviceDescriptor) {
  const browser = await getBrowser(deviceDescriptor);
  return browser.newPage(deviceDescriptor);
}

// src/capture.ts
import { defaultConfig } from "@pixeleye/cli-config";
import { logger } from "@pixeleye/cli-logger";
import { createRequire } from "module";
var rrwebScript;
try {
  rrwebScript = __require.resolve("rrweb-snapshot/dist/rrweb-snapshot.min.js");
} catch {
  const require2 = createRequire(import.meta.url);
  rrwebScript = require2.resolve("rrweb-snapshot/dist/rrweb-snapshot.min.js");
}
var blankPage = "<!DOCTYPE html><html><head></head><body></body></html>";
var retries = 3;
async function captureScreenshot(options) {
  return new Promise(async (resolve, reject) => {
    let error;
    for (let i = 0; i < retries; i++) {
      const page = await getPage(options.device);
      const buffer = await internalCaptureScreenshot(page, options).catch(
        (err) => {
          logger.error(err);
          error = err;
        }
      );
      await page.close();
      if (buffer) {
        return resolve(buffer);
      }
    }
    logger.error(`Failed to capture screenshot after ${retries} retries`);
    reject(error);
  });
}
async function internalCaptureScreenshot(page, data) {
  if (!data.url) throw new Error("No url provided");
  if (data.serializedDom) {
    await page.route(
      "**/*",
      (route) => {
        route.fulfill({
          status: 200,
          contentType: "text/html",
          body: blankPage
        });
      },
      {
        times: 1
      }
    );
    await page.goto(data.url, {
      timeout: 6e4,
      waitUntil: "domcontentloaded"
    });
    await page.addScriptTag({
      path: rrwebScript
    });
    await page.evaluate((serializedDom) => {
      const r = window.rrwebSnapshot;
      const cache = r.createCache();
      const mirror = r.createMirror();
      r.rebuild(serializedDom, {
        doc: document,
        cache,
        mirror
      });
    }, data.serializedDom);
  } else {
    await page.goto(data.url, {
      timeout: 6e4
    });
  }
  const awaiters = [page.waitForLoadState("networkidle")];
  await page.waitForLoadState("load");
  await page.waitForLoadState("domcontentloaded");
  if (data.css) {
    await page.locator("body").first().evaluate((body, css) => {
      const style = document.createElement("style");
      style.innerHTML = css;
      body.appendChild(style);
      return true;
    }, data.css);
  }
  awaiters.push(
    page.waitForFunction(() => document.fonts.ready).catch(() => {
      logger.info("Timed out waiting for document fonts to be ready");
    })
  );
  if (data.waitForSelectors && data.waitForSelectors.length > 0)
    awaiters.push(
      ...data.waitForSelectors.map(
        (selector) => page.waitForSelector(selector, {
          timeout: 6e4
        })
      )
    );
  if (data.selector)
    awaiters.push(
      page.waitForSelector(data.selector, {
        timeout: 6e4
      })
    );
  if (data.wait) awaiters.push(page.waitForTimeout(data.wait));
  await Promise.all(awaiters);
  const locatedPage = data.selector ? page.locator(data.selector) : page;
  const mask = [...data?.maskSelectors || [], "[data-pixeleye-mask]"].map(
    (selector) => locatedPage.locator(selector)
  );
  const file = await locatedPage.screenshot({
    fullPage: data.fullPage,
    type: "png",
    mask,
    scale: data.scale || "device",
    maskColor: data?.maskColor || defaultConfig.maskColor,
    timeout: 6e4
  });
  await page.close();
  return file;
}
export {
  captureScreenshot,
  getBrowser,
  getPage
};
