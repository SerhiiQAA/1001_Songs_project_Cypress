// src/api.ts
import { getAPI as getAPITypes } from "api-typify";
import { fetch, Response } from "undici";
var fetchRetry = (url, init, retries = 3, retryWait = 3e3) => fetch(url, init).catch(async (err) => {
  if (retries <= 0) {
    throw err;
  }
  await new Promise((resolve) => setTimeout(resolve, retryWait));
  return fetchRetry(url, init, retries - 1);
});
function createAPI(endpoint, headers) {
  return getAPITypes(
    endpoint,
    (url, options) => fetchRetry(
      url,
      {
        ...options,
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          ...headers,
          ...options?.headers
        }
      },
      options?.retries,
      options?.retryWait
    ).then(async (res) => {
      if (res.ok) {
        return res.json().catch(() => res);
      }
      const errMsg = await res.json().catch(() => res).then((json) => JSON.stringify(json));
      return Promise.reject(errMsg);
    }).catch((err) => {
      if (err instanceof Response) {
        return err.json().then((json) => {
          throw new Error(JSON.stringify(json));
        }).catch(() => {
          throw err;
        });
      }
      throw err;
    })
  );
}
function API({
  endpoint,
  token
}) {
  return createAPI(endpoint, {
    Authorization: `Bearer ${token}`
  });
}

// src/helpers/upload.ts
import { generateHash, getDimensions } from "@pixeleye/cli-image";
import { Blob } from "buffer";
import { fetch as fetch2 } from "undici";
async function uploadSnapshots(endpoint, token, files) {
  if (files.length === 0) return [];
  const api = API({ endpoint, token });
  const snapshots = await Promise.all(
    files.map(async ({ file, format }) => {
      const hash = generateHash(file);
      const { height, width } = await getDimensions(file);
      return {
        hash,
        format,
        height,
        width,
        file
      };
    })
  );
  const presignedMap = await api.post("/v1/client/snapshots/upload", {
    body: {
      snapshots: snapshots.map(({ hash, height, width, format }) => ({
        hash,
        height,
        width,
        format
      }))
    }
  });
  const snapsToUpload = snapshots.filter(
    (snapshot) => Boolean(presignedMap[snapshot.hash].URL)
  );
  await Promise.all(
    snapsToUpload.map(({ file, hash, format }) => {
      const presigned = presignedMap[hash];
      const blob = new Blob([file], { type: format });
      return fetch2(presigned.URL, {
        method: presigned.Method,
        headers: {
          ...presigned.SignedHeader ? { Host: presigned.SignedHeader.Host.join(",") } : {},
          contentType: format
        },
        body: blob
      });
    })
  );
  return snapshots.map(({ hash }) => ({
    id: presignedMap[hash].id
  }));
}

// src/helpers/build.ts
import { getEnvironment, getMergeBase, getParentShas } from "@pixeleye/cli-env";
import { logger } from "@pixeleye/cli-logger";
async function getParentBuilds(api) {
  const env = await getEnvironment();
  const shas = await getParentShas(128);
  const branch = env.branch;
  logger.debug(`Checking for parent builds for ${branch}`);
  logger.debug(`Parent SHAs: ${shas.join(", ")}`);
  const builds = await api.post("/v1/client/latestBuilds", {
    body: {
      shas
    }
  }).catch((err) => {
    if (err.status === 401) {
      throw new Error("Unauthorized, please check your token");
    }
  });
  if (builds && builds.length > 0) {
    return builds;
  }
  const branchBuild = await api.post("/v1/client/builds", {
    queries: {
      branch
    }
  });
  if (branchBuild.length > 0) {
    return [branchBuild[0]];
  }
  return [];
}
async function createBuild(api, options) {
  const env = await getEnvironment();
  if (!env.branch) {
    throw new Error("No branch found");
  } else if (!env.commit) {
    throw new Error("No commit found");
  }
  if (options?.shardingCount && !options?.shardID) {
    options.shardID = env.shardID;
    if (!options.shardID) {
      throw new Error(
        "No shard ID found, please set it with --shard or PIXELEYE_SHARD_ID"
      );
    }
  }
  const parentBuilds = await getParentBuilds(api) || [];
  let targetBuildIDs = [];
  if (env.isPR) {
    if (!env.targetBranch) {
      throw new Error(
        "No PR branch name not found, please set the environment variable PIXELEYE_PR_BRANCH"
      );
    }
    const mergeBase = await getMergeBase(env.targetBranch).catch(
      () => void 0
    );
    if (mergeBase === void 0) {
      console.warn(
        `No merge base found for ${env.targetBranch}, we will attempt to use the latest build in that branch. This could mean we aren't accurately testing the changes in this PR.`
      );
    }
    let mergeBaseBuild = await api.post("/v1/client/builds", {
      body: {
        shas: mergeBase ? [mergeBase] : void 0
      },
      queries: {
        limit: mergeBase ? 10 : 1,
        branch: mergeBase ? void 0 : env.targetBranch
      }
    });
    if (mergeBaseBuild.length === 0 && mergeBase) {
      mergeBaseBuild = await api.post("/v1/client/builds", {
        queries: {
          branch: env.targetBranch,
          limit: 1
        }
      });
    }
    if (mergeBaseBuild.length === 0) {
      throw new Error(
        `No build found for ${env.targetBranch}, please run pixeleye on that branch first`
      );
    }
    targetBuildIDs = mergeBaseBuild.map((build2) => build2.id);
  } else {
    targetBuildIDs = parentBuilds?.map((build2) => build2.id);
  }
  const build = api.post("/v1/client/builds/create", {
    body: {
      branch: env.branch,
      sha: env.commit,
      targetBuildIDs,
      parentIDs: parentBuilds?.map((build2) => build2.id),
      targetBranch: env.targetBranch,
      prID: env.prID?.toString(),
      title: env.title,
      shardingCount: Number(options?.shardingCount) || void 0,
      // Avoids sending 0
      shardingID: options?.shardID?.toString() || void 0
      // Avoids sending ""
    }
  });
  return build;
}
export {
  API,
  createBuild,
  fetchRetry,
  getParentBuilds,
  uploadSnapshots
};
