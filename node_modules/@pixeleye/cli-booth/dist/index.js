// src/server.ts
import polka from "polka";
import bodyParser from "body-parser";
import { getEnvConfig as getEnvConfig2 } from "@pixeleye/cli-config";

// src/snapshotQueue.ts
import {
  captureScreenshot
} from "@pixeleye/cli-capture";
import PQueue from "p-queue";
import { getEnvConfig } from "@pixeleye/cli-config";
var queue = new PQueue({
  // eslint-disable-next-line turbo/no-undeclared-env-vars
  concurrency: getEnvConfig().boothConcurrency
});
async function handleQueue({
  body,
  addToBusQueue
}) {
  const file = await captureScreenshot(body).then((file2) => ({
    file: file2,
    format: "png",
    name: body.name,
    variant: body.variant,
    target: body.device.name,
    viewport: `${body.device.viewport.width}x${body.device.viewport.height}`,
    targetIcon: body.device.icon
  }));
  addToBusQueue(file);
}

// src/server.ts
import { getBrowser } from "@pixeleye/cli-capture";

// src/bus.ts
function createBus(options) {
  const queue2 = [];
  let timer = void 0;
  let delay = options.delay;
  const process2 = async (autoStart) => {
    if (queue2.length === 0) {
      return;
    }
    const messages = queue2.splice(0, Math.min(queue2.length, options.batchSize));
    await options.handler(messages);
    if (!autoStart) return;
    if (queue2.length === 0) {
      timer = void 0;
    } else {
      timer = setTimeout(() => process2(true), delay);
    }
  };
  return {
    async add(message) {
      queue2.push(message);
      if (!timer) {
        timer = setTimeout(() => process2(true), delay);
      }
    },
    async hurryAndWait() {
      clearInterval(timer);
      if (queue2.length === 0) {
        return;
      }
      return new Promise(async (resolve) => {
        while (queue2.length > 0) {
          await process2(false);
        }
        resolve();
      });
    }
  };
}

// src/server.ts
import { API, uploadSnapshots } from "@pixeleye/cli-api";
function warmUpBrowsers() {
  const devices = getEnvConfig2().devices;
  if (!devices) {
    return;
  }
  for (const device of devices) {
    getBrowser(device);
  }
}
function startServer(options) {
  return new Promise((resolve, _) => {
    const api = API({ endpoint: options.endpoint, token: options.token });
    const bus = createBus({
      batchSize: 10,
      delay: 5e3,
      handler: async (snapshots) => {
        await uploadSnapshots(options.endpoint, options.token, snapshots).then(
          (ids) => ids.length > 0 && api.post("/v1/client/builds/{id}/upload", {
            params: {
              id: options.buildID
            },
            body: {
              snapshots: snapshots.map((body, i) => ({
                name: body.name,
                variant: body.variant,
                snapID: ids[i].id,
                target: body.target,
                viewport: body.viewport,
                targetIcon: body.targetIcon
              }))
            }
          })
        );
      }
    });
    const app = polka().use(
      bodyParser.json({
        limit: "100mb"
      })
    );
    process.env["PW_TEST_SCREENSHOT_NO_FONTS_READY"] = "true";
    warmUpBrowsers();
    app.get("/ping", (_2, res) => {
      res.end("pong");
    });
    app.post("/snapshot", (req, res) => {
      const body = req.body;
      body.devices.forEach((device) => {
        queue.add(
          async () => handleQueue({
            ...options,
            body: {
              ...body,
              device
            },
            addToBusQueue: bus.add
          })
        );
      });
      res.end("ok");
    });
    app.get("/finished", async (_2, res) => {
      await queue.onIdle();
      await bus.hurryAndWait();
      res.end("ok");
    });
    app.listen(options.port, () => {
      resolve({
        close: () => app.server?.close()
      });
    });
  });
}

// src/client.ts
import { fetchRetry } from "@pixeleye/cli-api";
function ping(opts) {
  return fetchRetry(`${opts.endpoint}/ping`, void 0, 10);
}
function snapshot(opts, data) {
  return fetchRetry(`${opts.endpoint}/snapshot`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(data)
  });
}
function finished(opts) {
  return fetchRetry(`${opts.endpoint}/finished`);
}
export {
  finished,
  ping,
  snapshot,
  startServer
};
